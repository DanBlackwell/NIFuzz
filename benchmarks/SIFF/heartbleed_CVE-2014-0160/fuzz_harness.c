// Copyright 2016 Google Inc. All Rights Reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
#include <unistd.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <assert.h>
#include <stdint.h>
#include <stddef.h>
#include <stdio.h>
#include "memory.h"

__AFL_FUZZ_INIT();

SSL_CTX *Init() {
  SSL_library_init();
  SSL_load_error_strings();
  ERR_load_BIO_strings();
  OpenSSL_add_all_algorithms();
  SSL_CTX *sctx;
  assert (sctx = SSL_CTX_new(TLSv1_method()));
  /* These two file were created with this command:
      openssl req -x509 -newkey rsa:512 -keyout server.key \
     -out server.pem -days 9999 -nodes -subj /CN=a/
  */
  assert(SSL_CTX_use_certificate_file(sctx, "runtime/server.pem",
                                      SSL_FILETYPE_PEM));
  assert(SSL_CTX_use_PrivateKey_file(sctx, "runtime/server.key",
                                     SSL_FILETYPE_PEM));
  return sctx;
}

int main(void) {
  __AFL_INIT();

  #define MAX_LEN (65 * 1024)
  static char output[MAX_LEN];
  static char output_string[2 * MAX_LEN + 20];
  static char hex_str[]= "0123456789abcdef";


  static unsigned char *Data = __AFL_FUZZ_TESTCASE_BUF;  // must be after __AFL_INIT
  static int Size = __AFL_FUZZ_TESTCASE_LEN;  // don't use the macro directly in a
                                        // call!

  static uint32_t public_len = *(unsigned int *)Data;
  static uint32_t secret_len = Size - public_len - sizeof(public_len);
  static const uint8_t *public_in = Data + sizeof(public_len);
  static const uint8_t *secret_in = public_in + public_len;

  // Init this before seeding memory as openSSL has it's own malloc which assumes
  // cleared mem it seems
  static SSL_CTX *sctx;
  sctx = Init();

  initMemFillBuf(secret_in, secret_len);
  enableMemWrap();

  static SSL *server = SSL_new(sctx);
  static BIO *sinbio = BIO_new(BIO_s_mem());
  static BIO *soutbio = BIO_new(BIO_s_mem());
  SSL_set_bio(server, sinbio, soutbio);
  SSL_set_accept_state(server);

  FILL_STACK(secret_in, secret_len);

  BIO_write(sinbio, public_in, public_len);
  SSL_do_handshake(server);

  static int pos;
  // int readLen = BIO_read(sinbio, output, 65 * 1024);
  // pos = sprintf(output_string, "IN BIO: ");
  // for (int i = 0; i < readLen; i++) {
  //   output_string[pos++] = hex_str[(output[i] >> 4) & 0x0F];
  //   output_string[pos++] = hex_str[output[i] & 0x0F];
  // }
  // output_string[pos] = 0;
  // puts(output_string);

  static int readLen = BIO_read(soutbio, output, 65 * 1024);
  pos = sprintf(output_string, "OUT BIO: ");
  static int i;
  for (i = 0; i < readLen; i++) {
    output_string[pos++] = hex_str[(output[i] >> 4) & 0x0F];
    output_string[pos++] = hex_str[output[i] & 0x0F];
  }
  output_string[pos] = 0;
  puts(output_string);
  // fflush(stdout);

  // disable our malloc wrapper so that the server can be freed nicely
  disableMemWrap();
  SSL_free(server);
  return 0;
}

