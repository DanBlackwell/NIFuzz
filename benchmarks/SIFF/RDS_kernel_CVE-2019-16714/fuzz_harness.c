#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

typedef uint8_t __u8;
typedef uint16_t __u16;
typedef uint32_t __u32;
typedef uint64_t __u64;
typedef uint16_t __be16;
typedef uint32_t __be32;
typedef uint64_t __be64;
typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef __u16 __sum16;

/*
 * Maximum space available for extension headers.
 */
#define RDS_HEADER_EXT_SPACE	16

struct rds_header {
	__be64	h_sequence;
	__be64	h_ack;
	__be32	h_len;
	__be16	h_sport;
	__be16	h_dport;
	u8	h_flags;
	u8	h_credit;
	u8	h_padding[4];
	__sum16	h_csum;

	u8	h_exthdr[RDS_HEADER_EXT_SPACE];
};

struct rds_incoming {
	// refcount_t		i_refcount;
	// struct list_head	i_item;
	// struct rds_connection	*i_conn;
	// struct rds_conn_path	*i_conn_path;
	struct rds_header	i_hdr;
	// unsigned long		i_rx_jiffies;
	// struct in6_addr		i_saddr;

	// rds_rdma_cookie_t	i_rdma_cookie;
	// ktime_t			i_rx_tstamp;
	// u64			i_rx_lat_trace[RDS_RX_MAX_TRACES];
};

struct page {
	unsigned long flags;		/* Atomic flags, some possibly
					 * updated asynchronously */
    // ... Most members have been removed here as the kernel can deal with paging for us
} _struct_page_alignment;

struct rds_info_iterator {
	struct page **pages;
	void *addr;
	unsigned long offset;
};

struct in6_addr {
	union {
		__u8		u6_addr8[16];
#if __UAPI_DEF_IN6_ADDR_ALT
		__be16		u6_addr16[8];
		__be32		u6_addr32[4];
#endif
	} in6_u;
#define s6_addr			in6_u.u6_addr8
#if __UAPI_DEF_IN6_ADDR_ALT
#define s6_addr16		in6_u.u6_addr16
#define s6_addr32		in6_u.u6_addr32
#endif
};

struct rds6_info_message {
	__u64	seq;
	__u32	len;
	struct in6_addr	laddr;
	struct in6_addr	faddr;
	__be16		lport;
	__be16		fport;
	__u8		flags;
	__u8		tos;
} __attribute__((packed));

unsigned long min(unsigned long in1, unsigned long in2) {
    return in1 < in2 ? in1 : in2;
}

/*
 * get_user_pages() called flush_dcache_page() on the pages for us.
 */
void rds_info_copy(struct rds_info_iterator *iter, void *data,
		   unsigned long bytes)
{
	unsigned long this;

	while (bytes) {
		// if (!iter->addr)
		// 	iter->addr = kmap_atomic(*iter->pages);

        size_t page_size = getpagesize();
		this = min(bytes, page_size - iter->offset);

		// rdsdebug("page %p addr %p offset %lu this %lu data %p "
		// 	  "bytes %lu\n", *iter->pages, iter->addr,
		// 	  iter->offset, this, data, bytes);

        write(1, data, this);
		memcpy(iter->addr + iter->offset, data, this);

		data += this;
		bytes -= this;
		iter->offset += this;

		if (iter->offset == page_size) {
			// kunmap_atomic(iter->addr);
			iter->addr = NULL;
			iter->offset = 0;
			iter->pages++;
		}
	}
}

// For the purpose of detecting errors through fuzzing, endianness is unimportant
__u64 be64_to_cpu(__be64 input) {
    return input;
}

__u32 be32_to_cpu(__be32 input) {
    return input;
}

void rds6_inc_info_copy(struct rds_incoming *inc,
			struct rds_info_iterator *iter,
			struct in6_addr *saddr, struct in6_addr *daddr,
			int flip)
{
	struct rds6_info_message minfo6;

	minfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);
	minfo6.len = be32_to_cpu(inc->i_hdr.h_len);
//	minfo6.tos = inc->i_conn->c_tos;  // FIX!

	if (flip) {
		minfo6.laddr = *daddr;
		minfo6.faddr = *saddr;
		minfo6.lport = inc->i_hdr.h_dport;
		minfo6.fport = inc->i_hdr.h_sport;
	} else {
		minfo6.laddr = *saddr;
		minfo6.faddr = *daddr;
		minfo6.lport = inc->i_hdr.h_sport;
		minfo6.fport = inc->i_hdr.h_dport;
	}

//	minfo6.flags = 0;  // FIX!

	rds_info_copy(iter, &minfo6, sizeof(minfo6));
}


#include "memory.h"
#include <stdio.h>

__AFL_FUZZ_INIT();

int main(void) {
  static struct rds_incoming inc = {0};
  static struct rds_info_iterator iter = {0};
  static struct in6_addr saddr = {0}, daddr = {0};
  static int flip = 0;

  __AFL_INIT();

  initHeapMemFillBuf(HEAP_MEM_IN, HEAP_MEM_LEN);

  static size_t pos = 0;

#define COPY_INTO(x) if (EXPLICIT_PUBLIC_LEN - pos >= sizeof(x)) { memcpy(&x, EXPLICIT_PUBLIC_IN + pos, sizeof(x)); pos += sizeof(x); } else { return 1; }

  COPY_INTO(inc);

// struct rds_info_iterator {
//  struct page **pages;
//  void *addr;
//  unsigned long offset;
// };
  COPY_INTO(iter);

  static int num_pages;
  num_pages = (int)ceil((float)sizeof(struct rds6_info_message) / getpagesize());
  static struct page **pages;
  pages = malloc(num_pages * sizeof(struct page *));
  
  static int i;
  for (i = 0; i < num_pages; i++) {
      pages[i] = calloc(1, sizeof(struct page));
  }
  
  iter.pages = pages;
  iter.addr = *pages;
  iter.offset = 0;

  COPY_INTO(saddr);
  COPY_INTO(daddr);
  COPY_INTO(flip);
  flip = flip > 128 ? 1 : 0;

  FILL_STACK(STACK_MEM_IN, STACK_MEM_LEN);

  rds6_inc_info_copy(&inc, &iter, &saddr, &daddr, flip);
  fflush(stdout);
}