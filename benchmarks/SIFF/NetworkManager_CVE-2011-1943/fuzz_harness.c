#include "nm-setting-vpn.h"
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <glib.h>

#include "memory.h"

GType nm_setting_connection_get_type() {
  return 1;
}

char *fetchString(int minLen, int maxLen, const unsigned char *buf, int bufLen, int *bufPos) {
  if (*bufPos == bufLen) {
    char *string = malloc(1);
    if (!string) exit(1);
    string[0] = 0;
    return string;
  }

  int stringLen = buf[*bufPos] % (maxLen - minLen) + minLen; // select len between 5 and 20
  (*bufPos)++;
  stringLen = bufLen - *bufPos >= stringLen ? stringLen : bufLen - *bufPos;

  char *string = malloc(stringLen + 1);
  if (!string) exit(1);
  memcpy(string, buf + *bufPos, stringLen);
  string[stringLen] = 0;
  (*bufPos) += stringLen;

  return string;
}

void logFunc(const gchar *log_domain,
             GLogLevelFlags log_level,
             const gchar *message,
             gpointer user_data) 
{
  switch (log_level) {
	  case G_LOG_FLAG_RECURSION:
		  printf("RECURSION: "); break;
	  case G_LOG_FLAG_FATAL:
		  printf("FATAL: "); break;
	  case G_LOG_LEVEL_ERROR:
		  printf("ERROR: "); break;
	  case G_LOG_LEVEL_CRITICAL:
		  printf("CRITICAL: "); break;
	  case G_LOG_LEVEL_WARNING:
		  printf("WARNING: "); break;
	  case G_LOG_LEVEL_MESSAGE:
		  printf("MESSAGE: "); break;
	  case G_LOG_LEVEL_INFO:
		  printf("INFO: "); break;
	  case G_LOG_LEVEL_DEBUG:
		  printf("DEBUG: "); break;
	  case G_LOG_LEVEL_MASK:
		  printf("MASK: "); break;
  }

  printf("%s\n", message);
}

__AFL_FUZZ_INIT();

int main(void) {

  __AFL_INIT();

  NMSetting *setting;

  setting = nm_setting_vpn_new();

  g_log_set_default_handler(logFunc, NULL);

//  initHeapMemFillBuf(HEAP_MEM_IN, HEAP_MEM_LEN);
//  FILL_STACK(STACK_MEM_IN, STACK_MEM_LEN);

  static int pub_pos = 0, sec_pos = 0;
  while (pub_pos < EXPLICIT_PUBLIC_LEN) {
    static int fn;
    fn = EXPLICIT_PUBLIC_IN[pub_pos++] % 7;

    static char *key, *item;
 
    switch(fn) {
      case 0:
        printf("user_name: %s\n", nm_setting_vpn_get_user_name(setting));
        break;
      case 1:
        printf("service_type: %s\n", nm_setting_vpn_get_service_type(setting));
        break;
      case 2:
        key = fetchString(5, 20, EXPLICIT_PUBLIC_IN, EXPLICIT_PUBLIC_LEN, &pub_pos);
        item = fetchString(5, 20, EXPLICIT_PUBLIC_IN, EXPLICIT_PUBLIC_LEN, &pub_pos);
        //printf("adding item %s: %s\n", key, item);
        nm_setting_vpn_add_data_item(setting, key, item);
        free(key);
        free(item);
        break;
      case 3:
        printf("item %s: %s\n", key, nm_setting_vpn_get_data_item(setting, key));
        free(key);
        break;
      case 4:
        key = fetchString(5, 20, EXPLICIT_PUBLIC_IN, EXPLICIT_PUBLIC_LEN, &pub_pos);
        //printf("removing item %s\n", key);
        nm_setting_vpn_remove_data_item(setting, key);
        free(key);
        break;
      case 5:
        key = fetchString(5, 20, EXPLICIT_PUBLIC_IN, EXPLICIT_PUBLIC_LEN, &pub_pos);
        item = fetchString(5, 20, EXPLICIT_SECRET_IN, EXPLICIT_SECRET_LEN, &sec_pos);
        //printf("adding secret %s: %s\n", key, item);
        nm_setting_vpn_add_secret(setting, key, item);
        free(key);
        free(item);
        break;
      case 6:
        key = fetchString(5, 20, EXPLICIT_PUBLIC_IN, EXPLICIT_PUBLIC_LEN, &pub_pos);
        //printf("removing secret %s\n", key);
        nm_setting_vpn_remove_secret(setting, key);
        free(key);
        break;
    }
  }
  fflush(stdout); 
  fflush(stderr); 

  g_object_unref(setting);
}
